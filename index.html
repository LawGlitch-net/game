<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Quoridor - P2P</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --grid: #333;
            --p1: #00e5ff; /* Cyan Pacman */
            --p2: #ff4081; /* Pink Ghost */
            --wall: #0056b3;
            --text: #eee;
        }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        
        /* CONNECTION UI */
        #setup { background: #222; padding: 20px; border-radius: 8px; border: 1px solid #444; max-width: 600px; width: 100%; margin-bottom: 20px; }
        textarea { width: 100%; height: 60px; background: #111; color: #0f0; border: 1px solid #555; font-size: 10px; resize: none; }
        button { cursor: pointer; padding: 8px 16px; margin: 5px 0; background: #444; color: white; border: none; border-radius: 4px; }
        button:hover { background: #666; }
        button.primary { background: var(--p1); color: #000; font-weight: bold; }
        .hidden { display: none !important; }
        .step { margin-bottom: 15px; border-left: 2px solid var(--p1); padding-left: 10px; }

        /* GAME BOARD */
        #game-container { position: relative; display: flex; flex-direction: column; align-items: center; }
        #board {
            display: grid;
            grid-template-columns: repeat(9, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 10px;
            background: #000;
            padding: 10px;
            border: 2px solid var(--wall);
            border-radius: 4px;
            position: relative;
        }
        .cell {
            width: 40px; height: 40px;
            background: #2a2a2a;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }
        .cell:hover { background: #333; }
        .cell.highlight { background: #444; box-shadow: inset 0 0 5px var(--p1); }
        
        /* PAWNS */
        .pawn {
            width: 30px; height: 30px;
            border-radius: 50%;
            position: absolute;
            top: 5px; left: 5px;
            transition: all 0.2s;
            box-shadow: 0 0 10px currentColor;
            z-index: 10;
        }
        .p1 { background: var(--p1); color: var(--p1); }
        .p2 { background: var(--p2); color: var(--p2); border-radius: 50% 50% 0 0; } /* Ghost shape hint */

        /* WALLS */
        .wall {
            position: absolute;
            background: var(--wall);
            box-shadow: 0 0 5px var(--wall);
            z-index: 5;
            border-radius: 2px;
        }
        .wall.h { height: 10px; width: 90px; margin-top: -10px; margin-left: 0; pointer-events: none; }
        .wall.v { width: 10px; height: 90px; margin-left: -10px; margin-top: 0; pointer-events: none; }
        
        /* GHOST WALLS (Hover) */
        .gap-h, .gap-v { position: absolute; background: transparent; z-index: 20; }
        .gap-h:hover { background: rgba(0, 229, 255, 0.3); cursor: pointer; }
        .gap-v:hover { background: rgba(0, 229, 255, 0.3); cursor: pointer; }

        #status { margin-top: 10px; font-size: 1.2em; font-weight: bold; }
        #turn-indicator { color: var(--p1); }
    </style>
</head>
<body>

<h1>Neon Quoridor MVP</h1>

<div id="setup">
    <h3>1. Connect Players</h3>
    <div id="setup-start">
        <p>Are you the Host or the Guest?</p>
        <button class="primary" onclick="initHost()">I am HOST (Player 1)</button>
        <button onclick="initGuest()">I am GUEST (Player 2)</button>
    </div>

    <div id="host-flow" class="hidden">
        <div class="step">
            <p>1. Copy this code and send it to your friend:</p>
            <textarea id="host-offer" readonly>Generating...</textarea>
            <button onclick="copyToClipboard('host-offer')">Copy Offer</button>
        </div>
        <div class="step">
            <p>2. Paste the code your friend sends back:</p>
            <textarea id="host-answer-input" placeholder="Paste Guest's answer here..."></textarea>
            <button class="primary" onclick="hostFinalize()">Start Game</button>
        </div>
    </div>

    <div id="guest-flow" class="hidden">
        <div class="step">
            <p>1. Paste the code from the Host:</p>
            <textarea id="guest-offer-input" placeholder="Paste Host's offer here..."></textarea>
            <button class="primary" onclick="guestProcessOffer()">Generate Answer</button>
        </div>
        <div class="step hidden" id="guest-answer-step">
            <p>2. Copy this code and send it back to the Host:</p>
            <textarea id="guest-answer" readonly></textarea>
            <button onclick="copyToClipboard('guest-answer')">Copy Answer</button>
        </div>
    </div>
    
    <div id="connection-status" style="color: yellow; margin-top: 10px;"></div>
</div>

<div id="game-container" class="hidden">
    <div id="status">Turn: <span id="turn-indicator">Player 1</span></div>
    <div style="margin: 10px; font-size: 0.9em; color: #aaa;">Click cells to move. Click gaps to place walls.</div>
    <div id="board">
        </div>
</div>

<script>
/** * GAME LOGIC 
 */
const BOARD_SIZE = 9;
const CELL_SIZE = 40;
const GAP_SIZE = 10;

let state = {
    p1: { x: 4, y: 0, walls: 10 },
    p2: { x: 4, y: 8, walls: 10 },
    walls: [], // {x, y, type: 'h'|'v'}
    turn: 1, // 1 or 2
    myPlayerId: null // 1 or 2
};

// Simple BFS to ensure path exists
function hasPath(playerPos, targetRow, walls) {
    let queue = [playerPos];
    let visited = new Set();
    visited.add(`${playerPos.x},${playerPos.y}`);

    while (queue.length > 0) {
        let {x, y} = queue.shift();
        if (y === targetRow) return true;

        const moves = [
            {dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}
        ];

        for (let m of moves) {
            let nx = x + m.dx;
            let ny = y + m.dy;
            
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9 && !visited.has(`${nx},${ny}`)) {
                if (!isBlocked(x, y, nx, ny, walls)) {
                    visited.add(`${nx},${ny}`);
                    queue.push({x: nx, y: ny});
                }
            }
        }
    }
    return false;
}

function isBlocked(x1, y1, x2, y2, walls) {
    // Check if a wall blocks the path between adjacent cells
    for (let w of walls) {
        if (w.type === 'h') {
            // Horizontal wall at (wx, wy) blocks movement between (wx, wy) and (wx, wy+1)
            // It spans x to x+1
            if (y1 !== y2 && Math.min(y1, y2) === w.y && (x1 === w.x || x1 === w.x + 1)) return true;
        } else {
            // Vertical wall at (wx, wy) blocks movement between (wx, wy) and (wx+1, wy)
            if (x1 !== x2 && Math.min(x1, x2) === w.x && (y1 === w.y || y1 === w.y + 1)) return true;
        }
    }
    return false;
}

function renderBoard() {
    const board = document.getElementById('board');
    board.innerHTML = ''; // Clear

    // Render Cells
    for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
            let d = document.createElement('div');
            d.className = 'cell';
            d.dataset.x = x;
            d.dataset.y = y;
            d.onclick = () => handleMoveClick(x, y);
            board.appendChild(d);
        }
    }

    // Render P1
    let p1 = document.createElement('div');
    p1.className = 'pawn p1';
    setPosition(p1, state.p1.x, state.p1.y);
    board.appendChild(p1);

    // Render P2
    let p2 = document.createElement('div');
    p2.className = 'pawn p2';
    setPosition(p2, state.p2.x, state.p2.y);
    board.appendChild(p2);

    // Render Walls
    state.walls.forEach(w => {
        let wd = document.createElement('div');
        wd.className = `wall ${w.type}`;
        // Visual positioning logic
        let left = w.x * (CELL_SIZE + GAP_SIZE);
        let top = w.y * (CELL_SIZE + GAP_SIZE);
        if (w.type === 'h') {
            top += CELL_SIZE; 
        } else {
            left += CELL_SIZE; 
        }
        wd.style.left = left + 'px';
        wd.style.top = top + 'px';
        board.appendChild(wd);
    });

    // Render Clickable Wall Gaps (Only if it's my turn)
    if (state.turn === state.myPlayerId) {
        renderWallGaps(board);
    }
    
    updateStatus();
}

function renderWallGaps(board) {
    // Horizontal Gaps (between rows)
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let g = document.createElement('div');
            g.className = 'gap-h';
            g.style.left = (x * (CELL_SIZE + GAP_SIZE)) + 'px';
            g.style.top = (y * (CELL_SIZE + GAP_SIZE) + CELL_SIZE) + 'px';
            g.style.width = (CELL_SIZE * 2 + GAP_SIZE) + 'px';
            g.style.height = GAP_SIZE + 'px';
            g.onclick = () => handleWallClick(x, y, 'h');
            board.appendChild(g);
        }
    }
    // Vertical Gaps (between cols)
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let g = document.createElement('div');
            g.className = 'gap-v';
            g.style.left = (x * (CELL_SIZE + GAP_SIZE) + CELL_SIZE) + 'px';
            g.style.top = (y * (CELL_SIZE + GAP_SIZE)) + 'px';
            g.style.width = GAP_SIZE + 'px';
            g.style.height = (CELL_SIZE * 2 + GAP_SIZE) + 'px';
            g.onclick = () => handleWallClick(x, y, 'v');
            board.appendChild(g);
        }
    }
}

function setPosition(el, x, y) {
    el.style.left = (x * (CELL_SIZE + GAP_SIZE) + 5) + 'px';
    el.style.top = (y * (CELL_SIZE + GAP_SIZE) + 5) + 'px';
}

function updateStatus() {
    const ind = document.getElementById('turn-indicator');
    ind.innerText = state.turn === 1 ? "Player 1 (Blue)" : "Player 2 (Pink)";
    ind.style.color = state.turn === 1 ? "var(--p1)" : "var(--p2)";
    
    if(state.turn === state.myPlayerId) {
        ind.innerText += " - YOUR TURN";
    }
}

function handleMoveClick(x, y) {
    if (state.turn !== state.myPlayerId) return;

    const me = state.turn === 1 ? state.p1 : state.p2;
    const dist = Math.abs(me.x - x) + Math.abs(me.y - y);

    // Basic move validation (1 step)
    // TODO: Add jump logic for full Quoridor rules
    if (dist === 1 && !isBlocked(me.x, me.y, x, y, state.walls)) {
        sendMove({ type: 'MOVE', x, y });
    }
}

function handleWallClick(x, y, type) {
    if (state.turn !== state.myPlayerId) return;
    
    // Check if wall overlaps
    const overlap = state.walls.some(w => {
        if (w.x === x && w.y === y) return true; // Exact match
        if (type === 'h' && w.type === 'h' && w.y === y && Math.abs(w.x - x) <= 1) return true; // Overlap H
        if (type === 'v' && w.type === 'v' && w.x === x && Math.abs(w.y - y) <= 1) return true; // Overlap V
        return false;
    });

    if (overlap) return alert("Wall blocked!");

    // Check if path still exists for both
    const testWalls = [...state.walls, {x, y, type}];
    if (!hasPath(state.p1, 8, testWalls) || !hasPath(state.p2, 0, testWalls)) {
        return alert("Cannot block path to goal!");
    }

    sendMove({ type: 'WALL', x, y, wallType: type });
}

function applyMove(data) {
    if (data.type === 'MOVE') {
        let p = state.turn === 1 ? state.p1 : state.p2;
        p.x = data.x;
        p.y = data.y;
    } else if (data.type === 'WALL') {
        state.walls.push({ x: data.x, y: data.y, type: data.wallType });
    }
    
    // Check Win
    if (state.p1.y === 8) alert("Player 1 Wins!");
    if (state.p2.y === 0) alert("Player 2 Wins!");

    state.turn = state.turn === 1 ? 2 : 1;
    renderBoard();
}

/**
 * WEBRTC NETWORKING (No External Libs)
 */
let pc, dataChannel;
const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function initHost() {
    state.myPlayerId = 1;
    document.getElementById('setup-start').classList.add('hidden');
    document.getElementById('host-flow').classList.remove('hidden');

    pc = new RTCPeerConnection(config);
    dataChannel = pc.createDataChannel("game");
    setupChannel(dataChannel);

    pc.onicecandidate = e => {
        if (!e.candidate) {
            document.getElementById('host-offer').value = JSON.stringify(pc.localDescription);
        }
    };
    
    pc.createOffer().then(d => pc.setLocalDescription(d));
}

function hostFinalize() {
    const answer = JSON.parse(document.getElementById('host-answer-input').value);
    pc.setRemoteDescription(answer);
}

function initGuest() {
    state.myPlayerId = 2;
    document.getElementById('setup-start').classList.add('hidden');
    document.getElementById('guest-flow').classList.remove('hidden');

    pc = new RTCPeerConnection(config);
    
    pc.ondatachannel = e => {
        setupChannel(e.channel);
    };

    pc.onicecandidate = e => {
        if (!e.candidate) {
            document.getElementById('guest-answer').value = JSON.stringify(pc.localDescription);
            document.getElementById('guest-answer-step').classList.remove('hidden');
        }
    };
}

function guestProcessOffer() {
    const offer = JSON.parse(document.getElementById('guest-offer-input').value);
    pc.setRemoteDescription(offer);
    pc.createAnswer().then(d => pc.setLocalDescription(d));
}

function setupChannel(channel) {
    channel.onopen = () => {
        document.getElementById('setup').classList.add('hidden');
        document.getElementById('game-container').classList.remove('hidden');
        renderBoard();
    };
    channel.onmessage = e => {
        const data = JSON.parse(e.data);
        applyMove(data);
    };
    dataChannel = channel;
}

function sendMove(moveData) {
    applyMove(moveData); // Update local
    dataChannel.send(JSON.stringify(moveData)); // Send to peer
}

// Utility
function copyToClipboard(id) {
    const el = document.getElementById(id);
    el.select();
    document.execCommand('copy');
    alert("Copied to clipboard!");
}
</script>
</body>
</html>
