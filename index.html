<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Purridor - Cat Path Game</title>
    <style>
        * { box-sizing: border-box; }
        
        :root {
            --bg: #faf8f3;
            --bg-secondary: #f5f0ea;
            --grid: #e8dfd7;
            --p1: #ff9fbf;
            --p2: #ffb366;
            --wall: #d4a5a5;
            --text: #6b5b52;
            --text-dim: #9a8f88;
            --accent: #ffb6d9;
            --border: #d4c4b8;
        }
        
        body {
            font-family: 'Comic Sans MS', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg) 0%, #fff5f0 100%);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 12px;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1 {
            margin: 15px 0;
            font-size: clamp(2em, 6vw, 3em);
            color: var(--p1);
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            letter-spacing: 2px;
        }
        
        /* CONNECTION UI */
        #setup {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(255, 182, 217, 0.15) 100%);
            padding: clamp(15px, 4vw, 25px);
            border-radius: 16px;
            border: 3px solid var(--border);
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
            box-shadow: 0 8px 24px rgba(255, 159, 191, 0.15);
        }
        
        #setup h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--p1);
            font-size: clamp(1.2em, 4vw, 1.5em);
            text-align: center;
        }
        
        #setup-start {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        #setup-start p {
            text-align: center;
            color: var(--text-dim);
            margin: 0 0 10px 0;
        }
        
        #setup-start button {
            padding: 14px 20px;
            font-size: clamp(0.9em, 2vw, 1em);
        }
        
        .step {
            margin-bottom: 20px;
            padding: 15px;
            border-left: 4px solid var(--p1);
            border-radius: 8px;
            background: rgba(255, 159, 191, 0.08);
        }
        
        .step p {
            margin: 0 0 10px 0;
            font-size: clamp(0.85em, 2vw, 0.95em);
            color: var(--text-dim);
        }
        
        textarea {
            width: 100%;
            height: 70px;
            background: #fff;
            color: #333;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 11px;
            resize: none;
            padding: 10px;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }
        
        button {
            cursor: pointer;
            padding: clamp(10px, 2vw, 12px) clamp(16px, 3vw, 24px);
            background: linear-gradient(135deg, #e8b8d8 0%, #f0c8e0 100%);
            color: white;
            border: 2px solid var(--p1);
            border-radius: 10px;
            font-weight: 700;
            font-size: clamp(0.85em, 2vw, 0.95em);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(255, 159, 191, 0.2);
        }
        
        button:hover {
            background: linear-gradient(135deg, #ffadd8 0%, #ffc0e0 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 159, 191, 0.3);
        }
        
        button.primary {
            background: linear-gradient(135deg, var(--p1) 0%, #ffb3d9 100%);
            color: white;
            border-color: #ff7fa8;
        }
        
        button.primary:hover {
            background: linear-gradient(135deg, #ffb3d9 0%, #ffcce5 100%);
            box-shadow: 0 6px 20px rgba(255, 159, 191, 0.4);
        }
        
        .hidden { display: none !important; }
        
        /* GAME BOARD CONTAINER */
        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }
        
        #status-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: linear-gradient(90deg, rgba(255, 159, 191, 0.15) 0%, rgba(255, 179, 102, 0.15) 100%);
            border-radius: 12px;
            border: 2px solid var(--border);
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        #status {
            font-size: clamp(1em, 3vw, 1.3em);
            font-weight: bold;
            flex: 1;
        }
        
        #turn-indicator {
            color: var(--p1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .wall-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 10px;
            border: 2px solid currentColor;
            font-size: clamp(0.85em, 2vw, 0.95em);
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .wall-counter.p1 {
            color: var(--p1);
        }
        
        .wall-counter.p2 {
            color: var(--p2);
        }
        
        .instructions {
            text-align: center;
            color: var(--text-dim);
            font-size: clamp(0.8em, 2vw, 0.9em);
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        /* GAME BOARD */
        #board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: clamp(4px, 1.5vw, 8px);
            background: linear-gradient(135deg, #fff9f5 0%, #fff5f0 100%);
            padding: clamp(10px, 2vw, 15px);
            border: 4px solid var(--border);
            border-radius: 16px;
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            max-width: 520px;
            box-shadow: 0 8px 32px rgba(255, 159, 191, 0.12), inset 0 0 20px rgba(255, 255, 255, 0.5);
        }
        
        .cell {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(135deg, #fff5f0 0%, #fff0eb 100%);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 2px solid var(--grid);
            transition: all 0.15s ease;
        }
        
        .cell:hover {
            background: linear-gradient(135deg, #ffecef 0%, #ffe5e8 100%);
            border-color: var(--p1);
            box-shadow: 0 0 8px rgba(255, 159, 191, 0.2);
        }
        
        .cell.valid-move {
            background: linear-gradient(135deg, rgba(255, 179, 102, 0.3) 0%, rgba(255, 159, 191, 0.2) 100%);
            border: 2px solid var(--p2);
            box-shadow: inset 0 0 8px rgba(255, 179, 102, 0.2), 0 0 12px rgba(255, 159, 191, 0.25);
        }
        
        /* PAWNS */
        .pawn {
            font-size: clamp(20px, 5vw, 36px);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 10;
            filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
        }
        
        .pawn:hover {
            filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.25));
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* WALLS */
        .wall {
            position: absolute;
            background: linear-gradient(90deg, var(--wall) 0%, #e0b8b8 100%);
            box-shadow: 0 2px 6px rgba(212, 165, 165, 0.4);
            z-index: 5;
            border-radius: 3px;
            pointer-events: none;
            border: 1px solid #c99a9a;
        }
        
        .wall.h {
            height: clamp(4px, 0.8vw, 7px);
            width: 100%;
        }
        
        .wall.v {
            width: clamp(4px, 0.8vw, 7px);
            height: 100%;
        }
        
        /* GHOST WALLS */
        .gap-h, .gap-v {
            position: absolute;
            background: transparent;
            z-index: 20;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.12s ease;
        }
        
        .gap-h:hover, .gap-v:hover {
            background: rgba(255, 179, 102, 0.4);
            border: 2px dashed var(--p2);
        }
        
        #connection-status {
            color: var(--text-dim);
            margin-top: 10px;
            font-size: clamp(0.85em, 2vw, 0.95em);
            text-align: center;
            font-weight: 600;
        }
        
        #connection-status.error {
            color: #d97171;
        }
        
        #connection-status.success {
            color: #a8d5a8;
        }
        
        @media (max-width: 600px) {
            body {
                padding: 8px;
            }
            
            #setup {
                margin-bottom: 15px;
            }
            
            #game-container {
                width: 100%;
            }
            
            #board {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>

<h1>üê± Purridor üê±</h1>

<div id="setup">
    <h3>Choose Your Player</h3>
    <div id="setup-start">
        <p>Who will you be?</p>
        <button class="primary" onclick="initHost()">üò∏ Sunny Cat (Host)</button>
        <button onclick="initGuest()">üòª Happy Cat (Guest)</button>
    </div>

    <div id="host-flow" class="hidden">
        <div class="step">
            <p>üìã Step 1: Copy and share this code:</p>
            <textarea id="host-offer" readonly>Generating...</textarea>
            <button onclick="copyToClipboard('host-offer')">üìã Copy</button>
        </div>
        <div class="step">
            <p>üìã Step 2: Paste the code from your friend:</p>
            <textarea id="host-answer-input" placeholder="Paste friend's code here..."></textarea>
            <button class="primary" onclick="hostFinalize()">‚ñ∂Ô∏è Start</button>
        </div>
    </div>

    <div id="guest-flow" class="hidden">
        <div class="step">
            <p>üìã Step 1: Paste the code from your friend:</p>
            <textarea id="guest-offer-input" placeholder="Paste friend's code here..."></textarea>
            <button class="primary" onclick="guestProcessOffer()">‚öôÔ∏è Generate Code</button>
        </div>
        <div class="step hidden" id="guest-answer-step">
            <p>üìã Step 2: Copy and send this code:</p>
            <textarea id="guest-answer" readonly></textarea>
            <button onclick="copyToClipboard('guest-answer')">üìã Copy</button>
        </div>
    </div>
    
    <div id="connection-status"></div>
</div>

<div id="game-container" class="hidden">
    <div id="status-bar">
        <div id="status">Turn: <span id="turn-indicator">Sunny</span></div>
        <div class="wall-counter p1" id="walls-p1">üß± P1: 10</div>
        <div class="wall-counter p2" id="walls-p2">üß± P2: 10</div>
    </div>
    
    <div class="instructions">
        <div>üëÜ Tap to move ‚Ä¢ üß± Tap gaps between cells to place walls</div>
    </div>
    
    <div id="board"></div>
</div>

<script>
const BOARD_SIZE = 9;

let state = {
    p1: { x: 4, y: 0, walls: 10 },
    p2: { x: 4, y: 8, walls: 10 },
    walls: [],
    turn: 1,
    myPlayerId: null
};

let boardScaling = { cellSize: 40, gapSize: 10 };

function updateBoardScaling() {
    const board = document.getElementById('board');
    if (!board) return;
    
    const maxWidth = Math.min(520, window.innerWidth - 40);
    const gapSize = Math.max(4, Math.floor(maxWidth * 0.015));
    const totalGaps = 8 * gapSize;
    const padding = 30;
    const availableSpace = maxWidth - padding - totalGaps;
    boardScaling.cellSize = Math.floor(availableSpace / 9);
    boardScaling.gapSize = gapSize;
}

window.addEventListener('resize', () => {
    updateBoardScaling();
    if (!document.getElementById('setup').classList.contains('hidden') === false) {
        renderBoard();
    }
});

function hasPath(playerPos, targetRow, walls) {
    let queue = [playerPos];
    let visited = new Set();
    visited.add(`${playerPos.x},${playerPos.y}`);

    while (queue.length > 0) {
        let {x, y} = queue.shift();
        if (y === targetRow) return true;

        const moves = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];

        for (let m of moves) {
            let nx = x + m.dx;
            let ny = y + m.dy;
            
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9 && !visited.has(`${nx},${ny}`)) {
                if (!isBlocked(x, y, nx, ny, walls)) {
                    visited.add(`${nx},${ny}`);
                    queue.push({x: nx, y: ny});
                }
            }
        }
    }
    return false;
}

function isBlocked(x1, y1, x2, y2, walls) {
    for (let w of walls) {
        if (w.type === 'h') {
            if (y1 < y2 && y2 - y1 === 1 && w.y === y1 && (w.x === x1 || w.x === x1 + 1)) return true;
            if (y1 > y2 && y1 - y2 === 1 && w.y === y2 && (w.x === x1 || w.x === x1 + 1)) return true;
        } else {
            if (x1 < x2 && x2 - x1 === 1 && w.x === x1 && (w.y === y1 || w.y === y1 + 1)) return true;
            if (x1 > x2 && x1 - x2 === 1 && w.x === x2 && (w.y === y1 || w.y === y1 + 1)) return true;
        }
    }
    return false;
}

function getValidMoves(playerPos, walls) {
    const moves = [];
    const directions = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
    
    for (let dir of directions) {
        const nx = playerPos.x + dir.dx;
        const ny = playerPos.y + dir.dy;
        
        if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
            if (!isBlocked(playerPos.x, playerPos.y, nx, ny, walls)) {
                moves.push({x: nx, y: ny});
            }
        }
    }
    return moves;
}

function getGridPosition(x, y) {
    const padding = 15;
    const left = padding + x * (boardScaling.cellSize + boardScaling.gapSize);
    const top = padding + y * (boardScaling.cellSize + boardScaling.gapSize);
    return { left, top };
}

function renderBoard() {
    updateBoardScaling();
    const board = document.getElementById('board');
    board.innerHTML = '';

    for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
            let d = document.createElement('div');
            d.className = 'cell';
            d.dataset.x = x;
            d.dataset.y = y;
            d.dataset.index = y * 9 + x;
            d.onclick = () => handleMoveClick(x, y);
            d.style.gridColumn = x + 1;
            d.style.gridRow = y + 1;
            board.appendChild(d);
        }
    }

    const validMoves = state.turn === state.myPlayerId 
        ? getValidMoves(state.turn === 1 ? state.p1 : state.p2, state.walls)
        : [];
    
    validMoves.forEach(m => {
        const cell = board.querySelector(`[data-x="${m.x}"][data-y="${m.y}"]`);
        if (cell) cell.classList.add('valid-move');
    });

    let p1 = document.createElement('div');
    p1.className = 'pawn';
    p1.innerText = 'üò∏';
    p1.style.gridColumn = state.p1.x + 1;
    p1.style.gridRow = state.p1.y + 1;
    board.appendChild(p1);

    let p2 = document.createElement('div');
    p2.className = 'pawn';
    p2.innerText = 'üòª';
    p2.style.gridColumn = state.p2.x + 1;
    p2.style.gridRow = state.p2.y + 1;
    board.appendChild(p2);

    state.walls.forEach(w => {
        let wd = document.createElement('div');
        wd.className = `wall ${w.type}`;
        
        if (w.type === 'h') {
            wd.style.gridColumn = (w.x + 1) + ' / span 2';
            wd.style.gridRow = (w.y + 1) + ' / span 1';
            wd.style.gridRowStart = w.y + 1.5;
        } else {
            wd.style.gridColumn = (w.x + 1) + ' / span 1';
            wd.style.gridRow = (w.y + 1) + ' / span 2';
            wd.style.gridColumnStart = w.x + 1.5;
        }
        
        board.appendChild(wd);
    });

    if (state.turn === state.myPlayerId) {
        renderWallGaps(board);
    }
    
    updateStatus();
}

function renderWallGaps(board) {
    const cellSize = boardScaling.cellSize;
    const gapSize = boardScaling.gapSize;
    const padding = 15;
    
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let g = document.createElement('div');
            g.className = 'gap-h';
            g.style.gridColumn = (x + 1) + ' / span 2';
            g.style.gridRow = (y + 1) + ' / span 1';
            g.style.gridRowStart = y + 1.5;
            g.style.height = gapSize + 'px';
            g.style.cursor = 'pointer';
            g.onclick = (e) => {
                e.stopPropagation();
                handleWallClick(x, y, 'h');
            };
            board.appendChild(g);
        }
    }
    
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let g = document.createElement('div');
            g.className = 'gap-v';
            g.style.gridColumn = (x + 1) + ' / span 1';
            g.style.gridRow = (y + 1) + ' / span 2';
            g.style.gridColumnStart = x + 1.5;
            g.style.width = gapSize + 'px';
            g.style.cursor = 'pointer';
            g.onclick = (e) => {
                e.stopPropagation();
                handleWallClick(x, y, 'v');
            };
            board.appendChild(g);
        }
    }
}

function updateStatus() {
    const ind = document.getElementById('turn-indicator');
    const playerName = state.turn === 1 ? "üò∏ Sunny" : "üòª Happy";
    let text = playerName;
    
    if(state.turn === state.myPlayerId) {
        text += " ‚≠ê YOUR TURN";
    }
    
    ind.innerText = text;
    ind.style.color = state.turn === 1 ? "var(--p1)" : "var(--p2)";
    
    document.getElementById('walls-p1').innerText = `üß± P1: ${state.p1.walls}`;
    document.getElementById('walls-p2').innerText = `üß± P2: ${state.p2.walls}`;
}

function handleMoveClick(x, y) {
    if (state.turn !== state.myPlayerId) return;

    const me = state.turn === 1 ? state.p1 : state.p2;
    const dist = Math.abs(me.x - x) + Math.abs(me.y - y);

    if (dist === 1 && !isBlocked(me.x, me.y, x, y, state.walls)) {
        sendMove({ type: 'MOVE', x, y });
    }
}

function handleWallClick(x, y, type) {
    if (state.turn !== state.myPlayerId) return;
    
    const me = state.turn === 1 ? state.p1 : state.p2;
    if (me.walls <= 0) {
        alert("No walls left!");
        return;
    }
    
    const overlap = state.walls.some(w => {
        if (w.x === x && w.y === y && w.type === type) return true;
        if (type === 'h' && w.type === 'h' && w.y === y && Math.abs(w.x - x) <= 1) return true;
        if (type === 'v' && w.type === 'v' && w.x === x && Math.abs(w.y - y) <= 1) return true;
        return false;
    });

    if (overlap) {
        alert("‚ö†Ô∏è Wall already there!");
        return;
    }

    const testWalls = [...state.walls, {x, y, type}];
    if (!hasPath(state.p1, 8, testWalls) || !hasPath(state.p2, 0, testWalls)) {
        alert("‚ö†Ô∏è Can't block the path!");
        return;
    }

    sendMove({ type: 'WALL', x, y, wallType: type });
}

function applyMove(data) {
    if (data.type === 'MOVE') {
        let p = state.turn === 1 ? state.p1 : state.p2;
        p.x = data.x;
        p.y = data.y;
    } else if (data.type === 'WALL') {
        state.walls.push({ x: data.x, y: data.y, type: data.wallType });
        const me = state.turn === 1 ? state.p1 : state.p2;
        me.walls--;
    }
    
    if (state.p1.y === 8) {
        alert("üéâ Sunny Cat Wins!");
        location.reload();
    }
    if (state.p2.y === 0) {
        alert("üéâ Happy Cat Wins!");
        location.reload();
    }

    state.turn = state.turn === 1 ? 2 : 1;
    renderBoard();
}

let pc, dataChannel;
const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function initHost() {
    state.myPlayerId = 1;
    document.getElementById('setup-start').classList.add('hidden');
    document.getElementById('host-flow').classList.remove('hidden');

    pc = new RTCPeerConnection(config);
    dataChannel = pc.createDataChannel("game");
    setupChannel(dataChannel);

    pc.onicecandidate = e => {
        if (!e.candidate) {
            document.getElementById('host-offer').value = JSON.stringify(pc.localDescription);
        }
    };
    
    pc.createOffer().then(d => pc.setLocalDescription(d));
}

function hostFinalize() {
    try {
        const answer = JSON.parse(document.getElementById('host-answer-input').value);
        pc.setRemoteDescription(answer);
        setStatus("‚úÖ Connected!", "success");
    } catch (e) {
        setStatus("‚ùå Invalid code!", "error");
    }
}

function initGuest() {
    state.myPlayerId = 2;
    document.getElementById('setup-start').classList.add('hidden');
    document.getElementById('guest-flow').classList.remove('hidden');

    pc = new RTCPeerConnection(config);
    
    pc.ondatachannel = e => {
        setupChannel(e.channel);
    };

    pc.onicecandidate = e => {
        if (!e.candidate) {
            document.getElementById('guest-answer').value = JSON.stringify(pc.localDescription);
            document.getElementById('guest-answer-step').classList.remove('hidden');
        }
    };
}

function guestProcessOffer() {
    try {
        const offer = JSON.parse(document.getElementById('guest-offer-input').value);
        pc.setRemoteDescription(offer);
        pc.createAnswer().then(d => pc.setLocalDescription(d));
        setStatus("‚è≥ Waiting for friend...", "success");
    } catch (e) {
        setStatus("‚ùå Invalid code!", "error");
    }
}

function setStatus(msg, cls) {
    const el = document.getElementById('connection-status');
    el.innerText = msg;
    el.className = cls;
}

function setupChannel(channel) {
    channel.onopen = () => {
        document.getElementById('setup').classList.add('hidden');
        document.getElementById('game-container').classList.remove('hidden');
        updateBoardScaling();
        renderBoard();
    };
    channel.onmessage = e => {
        const data = JSON.parse(e.data);
        applyMove(data);
    };
    dataChannel = channel;
}

function sendMove(moveData) {
    applyMove(moveData);
    dataChannel.send(JSON.stringify(moveData));
}

function copyToClipboard(id) {
    const el = document.getElementById(id);
    el.select();
    document.execCommand('copy');
    alert("‚úÖ Copied!");
}
</script>
</body>
</html>
